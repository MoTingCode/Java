/*
多态：可以理解为事物存在的多种体现形态。

1、多态的体现
	父类的引用指向了自己的子类对象。
	父类的引用也可以接受自己的子类对象。

2、多态的前提
	必须是类与类之间有关系，要么继承，要么实现。
	通常还有一个前提:存在覆盖。

3、多态的好处
	多态的出现大大滴提高了程序的扩展性。

4、多态弊端
	提高了扩展性，但是只能使用父类的引用访问父类的成员。

5、多态的应用
	
6、多态的出现代码中的特点
	
*/

abstract class Animal
{
	abstract void eat() ;
}

class Cat extends Animal
{
	public void eat()
	{
		System.out.println("吃鱼") ;
	}
	public void catchMouse()
	{
		System.out.println("抓老鼠") ;
	}
}

class Dog extends Animal
{
	public void eat()
	{
		System.out.println("吃骨头") ;
	}

	public void kanJia()
	{
		System.out.println("wangwang") ;
	}
}

class Pig extends Animal
{
	public void eat()
	{
		System.out.println("饲料") ;
	}
	public void gongDi()
	{
		System.out.println("拱地") ;
	}
}

class  test
{
	public static void main(String[] args) 
	{
	/*  Cat c = new Cat() ;
		c.eat() ;
		Dog d = new Dog() ;
		d.eat() ;
	*/


/*	    Animal a = new Cat() ; //父类的引用指向了自己的子类对象
		                         //类型提升，向上转型Cat->Animal
		a.eat() ;

	//如果想要调用猫的特有方法时，如何操作？
	//强制将父类的引用，转换成子类的类型
		Cat c = (Cat)a ;    //向下转型
		c.catchMouse() ;
        
	//	Animal d  = new Animal() ;   
	//	Cat e = (Cat)d ;  //千万不要出现这样的操作，就是将父类的对象转换成子类类型。
	                      //我们能转换的是父类引用指向了自己的子类对象时，该引用可以被提升也可以被强制转换。
                          //多态自始至终都是子类对象在做变化。
*/


		function(new Cat()) ; //Animal a = new Cat() ;
		function(new Dog()) ;

	}

	public static void function(Animal a)
	{
		a.eat() ;
		
		if(a instanceof Cat)  //判断所属类型
		{
			Cat c = (Cat)a ;
			c.catchMouse() ;
		}
		else if(a instanceof Dog)
		{
			Dog c = (Dog)a ;
			c.kanJia() ;
		}
	}

}
