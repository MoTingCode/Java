/*
子父类出现后，类成员的特点：

类中成员
1、变量
如果子类中出现非私有的同名成员变量时，子类要访问本类中的变量，用this；子类要访问父类中的同名变量，用super。
super的使用和this基本一致。
this代表的是本类对象的引用，super代表的是父类对象的引用。

2、函数
当子类出现和父类一样的函数时，若子类对象调用该函数，会运行子类函数的内容，如同父类的函数被覆盖一样。
这是函数的另外一个特征：重写（覆盖）

重写（覆盖）：当子类继承父类，沿袭了父类的功能到子类中。子类虽然具备了该功能，但是功能的内容却和父类不一致，
这时，没有必要定义新的功能，而是使用覆盖特性，保留父类的功能定义，重写功能定义（函数参数列表名不变），并重写功能内容（函数体重写）。

注意：
     1、子类覆盖父类，必须保证子类权限大于等于父类权限（public > 默认权限 > private），才可以覆盖，否则编译失败。
     2、静态只能覆盖静态。
     3、重载只看同名函数的参数列表，重写子父类方法要一模一样（返回值，函数名，参数列表）。

3、构造函数
在对子类对象进行初始化时，父类的构造函数也会运行，那是因为，子类的构造函数默认第一行有一条隐式的语句：super() ;
super()：会访问父类中空参数的构造函数，而且子类中所有的构造函数默认第一行都是super()。

为什么子类一定要访问父类的构造函数？
因为父类中的数据子类可以直接获取，所以子类对象在建立时，需要先查看父类是如何对这些数据进行初始化的。
所以子类在对象初始化时，要先访问一下父类中的构造函数。
如果要访问父类中指定的构造函数，可以通过手动定义super()语句的方式来进行。
注意：super语句一定要定义在子类构造函数的第一行。

子类的实例化过程：
结论：子类所有的构造函数，默认都会访问父类中空参数的构造函数，因为子类每一个构造函数内的第一行都有一句隐式super();
当父类中没有空参数的构造函数式，子类必须手动通过super语句形式来指定要访问的父类中的构造函数。
当然：子类的构造函数第一行也可以手动指定this语句来访问本类中的构造函数，子类中至少会有一个构造函数会访问父
类中的构造函数。
*/

class Fu
{
	int num = 4 ;

	Fu()
	{
		System.out.println("fu空构造函数") ;
	}

	Fu(int x)
	{
		System.out.println("fu非空构造函数"+x) ;
	}

	void show()
	{
		System.out.println("fu show") ;
	}

	void speak()
	{
		System.out.println("vb") ;
	}
}

class Zi extends Fu
{
	int num = 5 ;

	Zi()
	{
		//super() ;       //子类的构造函数默认第一行有一条隐式的语句：super() ;
		System.out.println("zi空构造函数") ;
	}

	Zi(int x)
	{
		//super() ;       //子类的构造函数默认第一行有一条隐式的语句：super() ;
		super(x) ;      //如果父类中不是空参数的构造函数，或者想要访问父类中非空参数的构造函数，可以通过这种方式指定。
		System.out.println("zi非空构造函数"+x) ;
	}




	void show()                         //this代表本类对象的引用，super代表父类对象的引用
	{
		System.out.println(num) ;        //这句打印的结果为5，因为实际上是System.out.println(this.num)
		System.out.println(super.num) ;  //这句打印的结果为4，super.num 代表父类的num
	} 

	void speak()
	{
		super.speak() ;  //这一句，实际上是在调用父类中的speak方法，注意加上super
		System.out.println("java") ;
	}
}

class  ExgtendsDemo
{
	public static void main(String[] args) 
	{
		Zi z = new Zi() ;
		Zi z1 = new Zi(4) ;
//		z.show() ;
//		z.speak() ;
	}
}

